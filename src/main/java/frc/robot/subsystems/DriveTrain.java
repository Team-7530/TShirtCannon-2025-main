// RobotBuilder Version: 3.1
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// ROBOTBUILDER TYPE: Subsystem.

package frc.robot.subsystems;

import com.revrobotics.spark.*;
import com.revrobotics.spark.SparkLowLevel.MotorType;
import com.revrobotics.spark.config.SparkBaseConfig;
import com.revrobotics.spark.config.SparkMaxConfig;
import com.revrobotics.spark.config.SparkBaseConfig.IdleMode;

// import com.ctre.phoenix.motorcontrol.ControlMode;
// import com.ctre.phoenix.motorcontrol.InvertType;
// import com.ctre.phoenix.motorcontrol.NeutralMode;
// import com.ctre.phoenix.motorcontrol.can.WPI_TalonFX;
import edu.wpi.first.wpilibj.XboxController;
import edu.wpi.first.wpilibj.drive.DifferentialDrive;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj2.command.SubsystemBase;
import frc.robot.Constants;

/** */
public class DriveTrain extends SubsystemBase {
  public enum DriveMode {
    ARCADE,
    TANK,
    CURVATURE
  }

  // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

  // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

  // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
  // private WPI_TalonFX leftMaster;
  // private WPI_TalonFX rightMaster;
  // private WPI_TalonFX leftFollower;
  // private WPI_TalonFX rightFollower;

  private SparkMax leftMaster;
  private SparkMax rightMaster;
  private SparkMax leftFollower;
  private SparkMax rightFollower;
  private DifferentialDrive differentialDrive;

  // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
  private DriveMode m_DriveMode = DriveMode.ARCADE;
  private boolean m_UseSquares = true;
  private boolean m_UseDriveScaling = true;
  private double m_DriveScaling = 0.1;
  private boolean m_QuickTurn = false;

  private double _lastLSmoothing = 0.0;
  private double _lastRSmoothing = 0.0;
  private SparkMaxConfig globalConfig_ = new SparkMaxConfig();
  private SparkMaxConfig RMconfig_ = new SparkMaxConfig();
  private SparkMaxConfig LFconfig_ = new SparkMaxConfig();
  private SparkMaxConfig RFconfig_ = new SparkMaxConfig();

  /** */
  public DriveTrain() {

    // leftMaster = new WPI_TalonFX(1);
    // rightMaster = new WPI_TalonFX(3);
    // leftFollower = new WPI_TalonFX(2);
    // rightFollower = new WPI_TalonFX(4);

    leftMaster = new SparkMax(Constants.kID_LMasterDrive, MotorType.kBrushless);
    leftFollower = new SparkMax(Constants.kID_LFollowDrive, MotorType.kBrushless);
    rightMaster = new SparkMax(Constants.kID_RMasterDrive, MotorType.kBrushless);
    rightFollower = new SparkMax(Constants.kID_RFollowDrive, MotorType.kBrushless);

    globalConfig_.smartCurrentLimit(50).idleMode(IdleMode.kBrake);
    RMconfig_.apply(globalConfig_).inverted(true);
    LFconfig_.apply(globalConfig_).follow(leftMaster);
    RFconfig_.apply(globalConfig_).follow(rightMaster);

    leftMaster.configure(globalConfig_, SparkBase.ResetMode.kResetSafeParameters, SparkBase.PersistMode.kPersistParameters);
    leftFollower.configure(LFconfig_, SparkBase.ResetMode.kResetSafeParameters, SparkBase.PersistMode.kPersistParameters);
    rightMaster.configure(RMconfig_, SparkBase.ResetMode.kResetSafeParameters, SparkBase.PersistMode.kPersistParameters);
    rightFollower.configure(RFconfig_, SparkBase.ResetMode.kResetSafeParameters, SparkBase.PersistMode.kPersistParameters);

    differentialDrive = new DifferentialDrive(leftMaster, rightMaster);
    addChild("Differential Drive", differentialDrive);
    differentialDrive.setSafetyEnabled(false);
    // differentialDrive.setSafetyEnabled(true);
    // differentialDrive.setExpiration(0.1);
    differentialDrive.setMaxOutput(1.0);

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS

    // leftFollower.configFactoryDefault();
    //leftFollower.restoreFactoryDefaults();
    //leftFollower.follow(leftMaster);
    //    leftFollower.setInverted(InvertType.FollowMaster);

    //rightMaster.setInverted(true);
    // rightFollower.configFactoryDefault();
    //rightFollower.restoreFactoryDefaults();
    //rightFollower.setInverted(true);
    //rightFollower.follow(rightMaster);
    //    rightFollower.setInverted(InvertType.FollowMaster);

    differentialDrive.setDeadband(0.02);
  }

  @Override
  public void periodic() {
    // This method will be called once per scheduler run

  }

  @Override
  public void simulationPeriodic() {
    // This method will be called once per scheduler run when in simulation

  }

  // Put methods for controlling this subsystem
  // here. Call these from Commands.
  public void setPercentVoltage(double leftPct, double rightPct) {
    // leftMaster.set(ControlMode.PercentOutput, leftPct);
    // rightMaster.set(ControlMode.PercentOutput, rightPct);
    leftMaster.set(leftPct);
    rightMaster.set(rightPct);
  }
  /** Completely stop the robot by setting the voltage to each side to be 0. */
  public void fullStop() {
    setPercentVoltage(0, 0);
    _lastLSmoothing = _lastRSmoothing = 0.0;
  }
  /** Disable the motors. */
  public void disable() {
    //leftMaster.disable();
    //rightMaster.disable();
  }

  public void enableDriveTrain(boolean enable) {
    differentialDrive.setSafetyEnabled(enable);
    if (enable) {
      setPercentVoltage(0, 0);
    } else {
      disable();
    }
  }

  public void enableBrakes(boolean enabled) {
    globalConfig_.idleMode(enabled ? SparkBaseConfig.IdleMode.kBrake : SparkBaseConfig.IdleMode.kCoast);
    RMconfig_.idleMode(enabled ? SparkBaseConfig.IdleMode.kBrake : SparkBaseConfig.IdleMode.kCoast);

    leftMaster.configure(globalConfig_, SparkBase.ResetMode.kResetSafeParameters, SparkBase.PersistMode.kPersistParameters);
    rightMaster.configure(RMconfig_, SparkBase.ResetMode.kResetSafeParameters, SparkBase.PersistMode.kPersistParameters);

    
    
    // leftMaster.setNeutralMode(enabled ? NeutralMode.Brake : NeutralMode.Coast);
    // rightMaster.setNeutralMode(enabled ? NeutralMode.Brake : NeutralMode.Coast);
    //leftMaster.setIdleMode(enabled ? SparkMax.IdleMode.kBrake : SparkMax.IdleMode.kCoast);
    //rightMaster.setIdleMode(enabled ? SparkMax.IdleMode.kBrake : SparkMax.IdleMode.kCoast);
  }

  public void setMaxOutput(double maxOutput) {
    differentialDrive.setMaxOutput(maxOutput);
  }

  public void driveArcade(double speed, double rotation, boolean useSquares) {
    differentialDrive.arcadeDrive(speed, rotation, useSquares);
  }

  public void driveTank(double leftSpeed, double rightSpeed) {
    differentialDrive.tankDrive(leftSpeed, rightSpeed);
  }

  public void driveCurvature(double speed, double rotation, boolean quickTurn) {
    differentialDrive.curvatureDrive(speed, rotation, quickTurn);
  }

  public void tankDriveVolts(double leftVolts, double rightVolts) {
    leftMaster.setVoltage(leftVolts);
    rightMaster.setVoltage(rightVolts);
    differentialDrive.feed();
  }

  public void drive(XboxController ctrl) {
    if (m_DriveMode == DriveMode.ARCADE) {
      this.setOutput(-ctrl.getLeftY(), ctrl.getRightX());
    } else if (m_DriveMode == DriveMode.TANK) {
      this.setOutput(-ctrl.getLeftY(), -ctrl.getRightY());
    } else if (m_DriveMode == DriveMode.CURVATURE) {
      this.setOutput(-ctrl.getLeftY(), ctrl.getRightX());
    }
  }

  public void setOutput(double left, double right) {
    double newleft = (_lastLSmoothing + left) / 2.0;
    double newRight = (_lastRSmoothing + right) / 2.0;
    _lastLSmoothing = left;
    _lastRSmoothing = right;

    if (m_DriveMode == DriveMode.ARCADE) {
      this.driveArcade(newleft, newRight, m_UseSquares);
    } else if (m_DriveMode == DriveMode.TANK) {
      this.driveTank(newleft, newRight);
    } else if (m_DriveMode == DriveMode.CURVATURE) {
      this.driveCurvature(newleft, newRight, m_QuickTurn);
    }
  }

  public DriveMode getDriveMode() {
    return m_DriveMode;
  }

  public void setDriveMode(DriveMode mode) {
    m_DriveMode = mode;
    SmartDashboard.putString("DriveTrainMode", m_DriveMode.toString());
  }

  public boolean getUseSquares() {
    return m_UseSquares;
  }

  public void setUseSquares(boolean use) {
    m_UseSquares = use;
    SmartDashboard.putBoolean("UseSquares", m_UseSquares);
  }

  public boolean getUseDriveScaling() {
    return m_UseDriveScaling;
  }

  public void setUseDriveScaling(boolean use) {
    System.out.println("setUseDriveScaling: " + (use ? "Yes" : "No"));
    m_UseDriveScaling = use;
    this.setMaxOutput(m_UseDriveScaling ? m_DriveScaling : 1.0);
    SmartDashboard.putBoolean("UseDriveScaling", m_UseDriveScaling);
  }

  public double getDriveScaling() {
    return m_DriveScaling;
  }

  public void setDriveScaling(double scaling) {
    System.out.println("setDriveScaling: " + scaling);
    m_DriveScaling = Math.max(Math.min(scaling, 1.0), 0.1);
    this.setMaxOutput(m_UseDriveScaling ? m_DriveScaling : 1.0);
    SmartDashboard.putNumber("DriveScaling", m_DriveScaling);
  }

  public boolean getQuickTurn() {
    return m_QuickTurn;
  }

  public void setQuickTurn(boolean turn) {
    m_QuickTurn = turn;
    SmartDashboard.putBoolean("UseQuickTurn", m_QuickTurn);
  }

  public void toggleDriveMode() {
    switch (m_DriveMode) {
      case ARCADE:
        setDriveMode(DriveMode.TANK);
        break;
      case TANK:
        setDriveMode(DriveMode.CURVATURE);
        break;
      case CURVATURE:
        setDriveMode(DriveMode.ARCADE);
        break;
      default:
        break;
    }
  }
}
